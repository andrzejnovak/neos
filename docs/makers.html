---

title: neos.makers

keywords: fastai
sidebar: home_sidebar

summary: "Functions that define the workflow from parametric observable --> statistical model."
description: "Functions that define the workflow from parametric observable --> statistical model."
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/01_makers.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This module contains example implementations of functions that are composed such that everything downstream is a function of the parameters of your observable.</p>
<ul>
<li><code>hists_from_nn_three_blobs(predict)</code> uses the nn decision function <code>predict</code> to form histograms from signal and background data, all drawn from multivariate normal distributions with different means. Two background distributions are sampled from, which is meant to mimic the situation in particle physics where one has a 'nominal' prediction for a nuisance parameter and then an alternate value (e.g. from varying up/down by one standard deviation), which then modifies the background pdf. Here, we take that effect to be a shift of the mean of the distribution. The value for the background histogram is then the mean of the resulting counts of the two modes, and the uncertainty can be quantified through the count standard deviation.</li>
<li><code>kde_counts_from_nn_three_blobs(predict, bins)</code> functions exactly as above, but uses a different method involving kernel density estimation to get the yields from the parameters of the observable, and needs the binning pre-specified as argument.</li>
<li><code>nn_hepdata_like(hmaker)</code> uses the resulting functions from either of the above (or your own!) methods to construct histograms, then feeds them into the <code>neos.models.hepdata_like</code> function that constructs a pyhf-like model. This can then be used to call things like <code>logpdf</code> and <code>expected_data</code> downstream when CLs values are calculated.</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="hists_from_nn_three_blobs" class="doc_header"><code>hists_from_nn_three_blobs</code><a href="https://github.com/phinate/neos/tree/master/neos/makers.py#L15" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>hists_from_nn_three_blobs</code>(<strong><code>predict</code></strong>, <strong><code>NMC</code></strong>=<em><code>500</code></em>, <strong><code>sig_mean</code></strong>=<em><code>[-1, 1]</code></em>, <strong><code>b1_mean</code></strong>=<em><code>[2, 2]</code></em>, <strong><code>b2_mean</code></strong>=<em><code>[-1, -1]</code></em>, <strong><code>LUMI</code></strong>=<em><code>10</code></em>, <strong><code>sig_scale</code></strong>=<em><code>2</code></em>, <strong><code>bkg_scale</code></strong>=<em><code>10</code></em>)</p>
</blockquote>
<p>Uses the nn decision function <code>predict</code> to form histograms from signal and background
data, all drawn from multivariate normal distributions with different means. Two
background distributions are sampled from, which is meant to mimic the situation in
particle physics where one has a 'nominal' prediction for a nuisance parameter and then
an alternate value (e.g. from varying up/down by one standard deviation), which then
modifies the background pdf. Here, we take that effect to be a shift of the mean of the
distribution. The value for the background histogram is then the mean of the resulting
counts of the two modes, and the uncertainty can be quantified through the count
standard deviation.</p>
<p>Args:
        predict: Decision function for a parameterized observable. Assumed softmax here.</p>
<p>Returns:
        hist_maker: A callable function that takes the parameters of the observable,
        then constructs signal, background, and background uncertainty yields.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="kde_counts_from_nn_three_blobs" class="doc_header"><code>kde_counts_from_nn_three_blobs</code><a href="https://github.com/phinate/neos/tree/master/neos/makers.py#L68" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>kde_counts_from_nn_three_blobs</code>(<strong><code>predict</code></strong>, <strong><code>bins</code></strong>, <strong><code>bandwidth</code></strong>=<em><code>0.3</code></em>, <strong><code>NMC</code></strong>=<em><code>500</code></em>, <strong><code>sig_mean</code></strong>=<em><code>[-1, 1]</code></em>, <strong><code>b1_mean</code></strong>=<em><code>[2, 2]</code></em>, <strong><code>b2_mean</code></strong>=<em><code>[-1, -1]</code></em>, <strong><code>LUMI</code></strong>=<em><code>10</code></em>, <strong><code>sig_scale</code></strong>=<em><code>2</code></em>, <strong><code>bkg_scale</code></strong>=<em><code>10</code></em>)</p>
</blockquote>
<p>Exactly the same as <a href="/neos/makers#hists_from_nn_three_blobs"><code>hists_from_nn_three_blobs</code></a>, but takes in a regression network, and
forms a kernel density estimate (kde) for the output. The yields are then calculated as
the integral of the kde's cumulative density function between the bin edges, which should
be specified as an argument to the function.</p>
<p>Args:
        predict: Decision function for a parameterized observable. When evaluated, the
        output should be one number per event, i.e. a regression network or similar.</p>
<p>Returns:
        hist_maker: A callable function that takes the parameters of the observable,
        then constructs signal, background, and background uncertainty yields.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="nn_hepdata_like" class="doc_header"><code>nn_hepdata_like</code><a href="https://github.com/phinate/neos/tree/master/neos/makers.py#L133" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>nn_hepdata_like</code>(<strong><code>histogram_maker</code></strong>)</p>
</blockquote>
<p>Returns a function that constructs a typical 'hepdata-like' statistical model
with signal, background, and background uncertainty yields when evaluated at
the parameters of the observable.</p>
<p>Args:
        histogram_maker: A function that, when called, returns a secondary function
        that takes the observable's parameters as argument, and returns yields.</p>
<p>Returns:
        nn_model_maker: A function that returns a Model object (either from
        <code>neos.models</code> or from <code>pyhf</code>) when evaluated at the observable's parameters.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

