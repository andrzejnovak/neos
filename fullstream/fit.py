# AUTOGENERATED! DO NOT EDIT! File to edit: 05_fit.ipynb (unless otherwise specified).

__all__ = ['get_solvers']

# Cell
import jax
from fax.implicit import twophase

from .transforms import *

# Cell
def get_solvers(
    model_constructor,
    pdf_transform=False,
    default_rtol=1e-10,
    default_atol=1e-10,
    default_max_iter=1000000,
):
    def make_model(hyper_pars):
        constrained_mu, nn_pars = hyper_pars[0], hyper_pars[1]
        m, bonlypars = model_constructor(nn_pars)

        bounds = m.config.suggested_bounds()

        exp_bonly_data = m.expected_data(bonlypars, include_auxdata=True) + 0.2

        def expected_logpdf(pars):  # maps pars to bounded space if pdf_transform = True

            return (
                m.logpdf(transform_lim_vec(pars, bounds), exp_bonly_data)
                if pdf_transform
                else m.logpdf(pars, exp_bonly_data)
            )

        def global_fit_objective(pars):  # NLL
            return -expected_logpdf(pars)[0]

        def constrained_fit_objective(nuis_par):  # NLL
            pars = jax.numpy.concatenate(
                [jax.numpy.asarray([constrained_mu]), nuis_par]
            )
            return -expected_logpdf(pars)[0]

        return constrained_mu, global_fit_objective, constrained_fit_objective

    def global_bestfit_minimized(hyper_param):
        _, nll, _ = make_model(hyper_param)

        def bestfit_via_grad_descent(i, param):  # gradient descent
            param = param - jax.grad(nll)(param) * 0.01
            return param

        return bestfit_via_grad_descent

    def constrained_bestfit_minimized(hyper_param):
        mu, nll, cnll = make_model(hyper_param)

        def bestfit_via_grad_descent(i, param):  # gradient descent
            _, np = param[0], param[1:]
            np = np - jax.grad(cnll)(np) * 0.01
            param = jax.numpy.concatenate([jax.numpy.asarray([mu]), np])
            return param

        return bestfit_via_grad_descent

    global_solve = twophase.two_phase_solver(
        param_func=global_bestfit_minimized,
        default_rtol=default_rtol,
        default_atol=default_atol,
        default_max_iter=default_max_iter,
    )
    constrained_solver = twophase.two_phase_solver(
        param_func=constrained_bestfit_minimized,
        default_rtol=default_rtol,
        default_atol=default_atol,
        default_max_iter=default_max_iter,
    )

    def g_fitter(init, hyper_pars):
        return global_solve(init, hyper_pars).value

    def c_fitter(init, hyper_pars):
        return constrained_solver(init, hyper_pars).value

    return g_fitter, c_fitter